networks:
    ai_diary_network:
        driver: bridge

services:
    # ----------------------------------------------------
    # 1. Laravelアプリケーションコンテナ (php-fpm)
    # ----------------------------------------------------
    app:
        build:
            context: .
            dockerfile: Dockerfile
        image: laravel-app
        container_name: ai_diary_app
        restart: always
        networks:
            - ai_diary_network
        volumes:
            # web-appディレクトリをコンテナの/var/www/htmlにマウント
            - ../web-app:/var/www/html
        env_file:
            - .env.docker
        healthcheck:
            test: ["CMD-SHELL", "php-fpm -t || exit 1"]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 40s
        depends_on:
            db:
                condition: service_healthy
            redis:
                condition: service_started

    # ----------------------------------------------------
    # 2. Nginx Webサーバーコンテナ
    # ----------------------------------------------------
    nginx:
        image: nginx:stable-alpine
        container_name: ai_diary_nginx
        restart: always
        networks:
            - ai_diary_network
        volumes:
            # web-appディレクトリをマウント
            - ../web-app:/var/www/html
            # カスタムNginx設定ファイルをコンテナにコピー（読み取り専用）
            - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
        ports:
            # 外部からアクセスするためのポート (Webブラウザ用)
            - '80:80'
        healthcheck:
            test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://127.0.0.1:80/health || exit 1"]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 40s
        depends_on:
            app:
                condition: service_healthy

    # ----------------------------------------------------
    # 3. MySQLデータベースコンテナ
    # ----------------------------------------------------
    db:
        image: mysql/mysql-server:8.0
        container_name: ai_diary_db
        restart: always
        networks:
            - ai_diary_network
        environment:
            # 開発用の簡単な認証情報
            MYSQL_ROOT_PASSWORD: root_password
            MYSQL_DATABASE: ai_diary_db
            MYSQL_USER: user
            MYSQL_PASSWORD: password
            TZ: 'Asia/Tokyo'
        ports:
            # ホストからの接続用
            - '3306:3306'
        volumes:
            # データをホスト側に永続化
            - db_data:/var/lib/mysql
            # 初期化SQLを置く場合（任意）
            # - ./docker/mysql/init:/docker-entrypoint-initdb.d
        healthcheck:
            test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "user", "-ppassword"]
            interval: 10s
            timeout: 5s
            retries: 10
            start_period: 30s

    # ----------------------------------------------------
    # 4. Redisコンテナ (キャッシュ, Laravel Queue用)
    # ----------------------------------------------------
    redis:
        image: redis:alpine
        container_name: ai_diary_redis
        restart: always
        networks:
            - ai_diary_network
        volumes:
            # データをホスト側に永続化
            - redis_data:/data
        healthcheck:
            test: ["CMD", "redis-cli", "ping"]
            interval: 10s
            timeout: 5s
            retries: 5
        # ローカルで直接触らないならポート公開不要
        # ports:
        #     - '6379:6379'

    # ----------------------------------------------------
    # 5. Laravel Queue Worker コンテナ (非同期処理用)
    # ----------------------------------------------------
    queue:
        build:
            context: .
            dockerfile: Dockerfile # appと同じDockerfileを使用
        image: laravel-worker
        container_name: ai_diary_queue_worker
        restart: always
        networks:
            - ai_diary_network
        volumes:
            # web-appディレクトリをマウント
            - ../web-app:/var/www/html
        env_file:
            - .env.docker
        # 起動時にワーカーを実行 (Supervisorは別途設定可能だが、ここではシンプルに)
        command: php artisan queue:work redis --tries=3 --timeout=60
        depends_on:
            app:
                condition: service_healthy
            redis:
                condition: service_healthy

volumes:
    db_data:
    redis_data:
